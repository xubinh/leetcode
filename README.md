# LeetCode

刷题记录

## <a id="toc"></a>目录

<details open="open"><summary><a href="#1">题目</a></summary>

- <a href="#1.1">1. 两数之和 | 简单</a>
- <a href="#1.2">2. 两数相加 | 中等</a>
- <a href="#1.3">3. 无重复字符的最长子串 | 中等</a>
- <a href="#1.4">4. 寻找两个正序数组的中位数 | 困难</a>
- <a href="#1.5">5. 最长回文子串 | 中等</a>
- <a href="#1.6">6. Z 字形变换 | 中等</a>
- <a href="#1.7">7. 整数反转 | 中等</a>
- <a href="#1.8">8. 字符串转换整数 (atoi) | 中等</a>
- <a href="#1.9">9. 回文数 | 简单</a>
- <a href="#1.10">10. 正则表达式匹配 | 困难</a>
- <a href="#1.11">11. 盛最多水的容器 | 中等</a>
- <a href="#1.12">12. 整数转罗马数字 | 中等</a>
- <a href="#1.13">13. 罗马数字转整数 | 简单</a>
- <a href="#1.14">14. 最长公共前缀 | 简单</a>
- <a href="#1.15">15. 三数之和 | 中等</a>
- <a href="#1.16">16. 最接近的三数之和 | 中等</a>
- <a href="#1.17">17. 电话号码的字母组合 | 中等</a>
- <a href="#1.18">18. 四数之和 | 中等</a>
- <a href="#1.19">19. 删除链表的倒数第 N 个结点 | 中等</a>
- <a href="#1.20">20. 有效的括号 | 简单</a>
- <a href="#1.21">21. 合并两个有序链表 | 简单</a>
- <a href="#1.22">22. 括号生成 | 中等</a>
- <a href="#1.23">23. 合并 K 个升序链表 | 困难</a>
- <a href="#1.24">25. K 个一组翻转链表 | 困难</a>
- <a href="#1.25">26. 删除有序数组中的重复项 | 简单</a>
- <a href="#1.26">28. 找出字符串中第一个匹配项的下标 | 简单</a>
- <a href="#1.27">29. 两数相除 | 中等</a>
- <a href="#1.28">31. 下一个排列 | 中等</a>
- <a href="#1.29">32. 最长有效括号 | 困难</a>
- <a href="#1.30">33. 搜索旋转排序数组 | 中等</a>
- <a href="#1.31">34. 在排序数组中查找元素的第一个和最后一个位置 | 中等</a>
- <a href="#1.32">35. 搜索插入位置 | 简单</a>
- <a href="#1.33">36. 有效的数独 | 中等</a>
- <a href="#1.34">38. 外观数列 | 中等</a>
- <a href="#1.35">39. 组合总和 | 中等</a>
- <a href="#1.36">40. 组合总和 II | 中等</a>
- <a href="#1.37">41. 缺失的第一个正数 | 困难</a>
- <a href="#1.38">42. 接雨水 | 困难</a>
- <a href="#1.39">43. 字符串相乘 | 中等</a>
- <a href="#1.40">44. 通配符匹配 | 困难</a>
- <a href="#1.41">45. 跳跃游戏 II | 中等</a>
- <a href="#1.42">46. 全排列 | 中等</a>
- <a href="#1.43">48. 旋转图像 | 中等</a>
- <a href="#1.44">49. 字母异位词分组 | 中等</a>
- <a href="#1.45">50. Pow(x, n) | 中等</a>
- <a href="#1.46">51. N 皇后 | 困难</a>
- <a href="#1.47">53. 最大子数组和 | 中等</a>
- <a href="#1.48">54. 螺旋矩阵 | 中等</a>
- <a href="#1.49">55. 跳跃游戏 | 中等</a>
- <a href="#1.50">56. 合并区间 | 中等</a>
- <a href="#1.51">58. 最后一个单词的长度 | 简单</a>
- <a href="#1.52">59. 螺旋矩阵 II | 中等</a>
- <a href="#1.53">61. 旋转链表 | 中等</a>
- <a href="#1.54">62. 不同路径 | 中等</a>
- <a href="#1.55">63. 不同路径 II | 中等</a>
- <a href="#1.56">64. 最小路径和 | 中等</a>
- <a href="#1.57">66. 加一 | 简单</a>
- <a href="#1.58">69. x 的平方根 | 简单</a>
- <a href="#1.59">70. 爬楼梯 | 简单</a>
- <a href="#1.60">72. 编辑距离 | 中等</a>
- <a href="#1.61">73. 矩阵置零 | 中等</a>
- <a href="#1.62">75. 颜色分类 | 中等</a>
- <a href="#1.63">76. 最小覆盖子串 | 困难</a>
- <a href="#1.64">78. 子集 | 中等</a>
- <a href="#1.65">79. 单词搜索 | 中等</a>
- <a href="#1.66">84. 柱状图中最大的矩形 | 困难</a>
- <a href="#1.67">85. 最大矩形 | 困难</a>
- <a href="#1.68">88. 合并两个有序数组 | 简单</a>
- <a href="#1.69">89. 格雷编码 | 中等</a>
- <a href="#1.70">91. 解码方法 | 中等</a>
- <a href="#1.71">92. 反转链表 II | 中等</a>
- <a href="#1.72">93. 复原 IP 地址 | 中等</a>
- <a href="#1.73">94. 二叉树的中序遍历 | 简单</a>
- <a href="#1.74">96. 不同的二叉搜索树 | 中等</a>
- <a href="#1.75">98. 验证二叉搜索树 | 中等</a>
- <a href="#1.76">101. 对称二叉树 | 简单</a>
- <a href="#1.77">102. 二叉树的层序遍历 | 中等</a>
- <a href="#1.78">103. 二叉树的锯齿形层序遍历 | 中等</a>
- <a href="#1.79">104. 二叉树的最大深度 | 简单</a>
- <a href="#1.80">105. 从前序与中序遍历序列构造二叉树 | 中等</a>
- <a href="#1.81">108. 将有序数组转换为二叉搜索树 | 简单</a>
- <a href="#1.82">114. 二叉树展开为链表 | 中等</a>
- <a href="#1.83">115. 不同的子序列 | 困难</a>
- <a href="#1.84">116. 填充每个节点的下一个右侧节点指针 | 中等</a>
- <a href="#1.85">118. 杨辉三角 | 简单</a>
- <a href="#1.86">119. 杨辉三角 II | 简单</a>
- <a href="#1.87">120. 三角形最小路径和 | 中等</a>
- <a href="#1.88">121. 买卖股票的最佳时机 | 简单</a>
- <a href="#1.89">122. 买卖股票的最佳时机 II | 中等</a>
- <a href="#1.90">124. 二叉树中的最大路径和 | 困难</a>
- <a href="#1.91">125. 验证回文串 | 简单</a>
- <a href="#1.92">127. 单词接龙 | 困难</a>
- <a href="#1.93">128. 最长连续序列 | 中等</a>
- <a href="#1.94">130. 被围绕的区域 | 中等</a>
- <a href="#1.95">131. 分割回文串 | 中等</a>
- <a href="#1.96">134. 加油站 | 中等</a>
- <a href="#1.97">135. 分发糖果 | 困难</a>
- <a href="#1.98">136. 只出现一次的数字 | 简单</a>
- <a href="#1.99">138. 随机链表的复制 | 中等</a>
- <a href="#1.100">139. 单词拆分 | 中等</a>
- <a href="#1.101">140. 单词拆分 II | 困难</a>
- <a href="#1.102">141. 环形链表 | 简单</a>
- <a href="#1.103">142. 环形链表 II | 中等</a>
- <a href="#1.104">143. 重排链表 | 中等</a>
- <a href="#1.105">146. LRU 缓存 | 中等</a>
- <a href="#1.106">148. 排序链表 | 中等</a>
- <a href="#1.107">149. 直线上最多的点数 | 困难</a>
- <a href="#1.108">150. 逆波兰表达式求值 | 中等</a>
- <a href="#1.109">152. 乘积最大子数组 | 中等</a>
- <a href="#1.110">153. 寻找旋转排序数组中的最小值 | 中等</a>
- <a href="#1.111">154. 寻找旋转排序数组中的最小值 II | 困难</a>
- <a href="#1.112">155. 最小栈 | 中等</a>
- <a href="#1.113">156. 上下翻转二叉树 | 中等</a>
- <a href="#1.114">157. 用 Read4 读取 N 个字符 | 简单</a>
- <a href="#1.115">158. 用 Read4 读取 N 个字符 II - 多次调用 | 困难</a>
- <a href="#1.116">159. 至多包含两个不同字符的最长子串 | 中等</a>
- <a href="#1.117">160. 相交链表 | 简单</a>
- <a href="#1.118">161. 相隔为 1 的编辑距离 | 中等</a>
- <a href="#1.119">162. 寻找峰值 | 中等</a>
- <a href="#1.120">163. 缺失的区间 | 简单</a>
- <a href="#1.121">165. 比较版本号 | 中等</a>
- <a href="#1.122">166. 分数到小数 | 中等</a>
- <a href="#1.123">169. 多数元素 | 简单</a>
- <a href="#1.124">170. 两数之和 III - 数据结构设计 | 简单</a>
- <a href="#1.125">171. Excel 表列序号 | 简单</a>
- <a href="#1.126">172. 阶乘后的零 | 中等</a>
- <a href="#1.127">179. 最大数 | 中等</a>
- <a href="#1.128">186. 反转字符串中的单词 II | 中等</a>
- <a href="#1.129">187. 重复的 DNA 序列 | 中等</a>
- <a href="#1.130">189. 轮转数组 | 中等</a>
- <a href="#1.131">190. 颠倒二进制位 | 简单</a>
- <a href="#1.132">191. 位 1 的个数 | 简单</a>
- <a href="#1.133">198. 打家劫舍 | 中等</a>
- <a href="#1.134">199. 二叉树的右视图 | 中等</a>
- <a href="#1.135">200. 岛屿数量 | 中等</a>
- <a href="#1.136">202. 快乐数 | 简单</a>
- <a href="#1.137">204. 计数质数 | 中等</a>
- <a href="#1.138">206. 反转链表 | 简单</a>
- <a href="#1.139">207. 课程表 | 中等</a>
- <a href="#1.140">208. 实现 Trie (前缀树) | 中等</a>
- <a href="#1.141">210. 课程表 II | 中等</a>
- <a href="#1.142">211. 添加与搜索单词 - 数据结构设计 | 中等</a>
- <a href="#1.143">212. 单词搜索 II | 困难</a>
- <a href="#1.144">213. 打家劫舍 II | 中等</a>
- <a href="#1.145">215. 数组中的第 K 个最大元素 | 中等</a>
- <a href="#1.146">217. 存在重复元素 | 简单</a>
- <a href="#1.147">218. 天际线问题 | 困难</a>
- <a href="#1.148">221. 最大正方形 | 中等</a>
- <a href="#1.149">223. 矩形面积 | 中等</a>
- <a href="#1.150">226. 翻转二叉树 | 简单</a>
- <a href="#1.151">227. 基本计算器 II | 中等</a>
- <a href="#1.152">229. 多数元素 II | 中等</a>
- <a href="#1.153">230. 二叉搜索树中第 K 小的元素 | 中等</a>
- <a href="#1.154">231. 2 的幂 | 简单</a>
- <a href="#1.155">234. 回文链表 | 简单</a>
- <a href="#1.156">235. 二叉搜索树的最近公共祖先 | 中等</a>
- <a href="#1.157">236. 二叉树的最近公共祖先 | 中等</a>
- <a href="#1.158">237. 删除链表中的节点 | 中等</a>
- <a href="#1.159">238. 除自身以外数组的乘积 | 中等</a>
- <a href="#1.160">239. 滑动窗口最大值 | 困难</a>
- <a href="#1.161">240. 搜索二维矩阵 II | 中等</a>
- <a href="#1.162">242. 有效的字母异位词 | 简单</a>
- <a href="#1.163">243. 最短单词距离 | 简单</a>
- <a href="#1.164">244. 最短单词距离 II | 中等</a>
- <a href="#1.165">245. 最短单词距离 III | 中等</a>
- <a href="#1.166">246. 中心对称数 | 简单</a>
- <a href="#1.167">247. 中心对称数 II | 中等</a>
- <a href="#1.168">248. 中心对称数 III | 困难</a>
- <a href="#1.169">249. 移位字符串分组 | 中等</a>
- <a href="#1.170">250. 统计同值子树 | 中等</a>
- <a href="#1.171">251. 展开二维向量 | 中等</a>
- <a href="#1.172">252. 会议室 | 简单</a>
- <a href="#1.173">253. 会议室 II | 中等</a>
- <a href="#1.174">254. 因子的组合 | 中等</a>
- <a href="#1.175">255. 验证二叉搜索树的前序遍历序列 | 中等</a>
- <a href="#1.176">256. 粉刷房子 | 中等</a>
- <a href="#1.177">258. 各位相加 | 简单</a>
- <a href="#1.178">259. 较小的三数之和 | 中等</a>
- <a href="#1.179">260. 只出现一次的数字 III | 中等</a>
- <a href="#1.180">261. 以图判树 | 中等</a>
- <a href="#1.181">265. 粉刷房子 II | 困难</a>
- <a href="#1.182">266. 回文排列 | 简单</a>
- <a href="#1.183">267. 回文排列 II | 中等</a>
- <a href="#1.184">268. 丢失的数字 | 简单</a>
- <a href="#1.185">269. 火星词典 | 困难</a>
- <a href="#1.186">270. 最接近的二叉搜索树值 | 简单</a>
- <a href="#1.187">271. 字符串的编码与解码 | 中等</a>
- <a href="#1.188">272. 最接近的二叉搜索树值 II | 困难</a>
- <a href="#1.189">273. 整数转换英文表示 | 困难</a>
- <a href="#1.190">276. 栅栏涂色 | 中等</a>
- <a href="#1.191">277. 搜寻名人 | 中等</a>
- <a href="#1.192">278. 第一个错误的版本 | 简单</a>
- <a href="#1.193">279. 完全平方数 | 中等</a>
- <a href="#1.194">280. 摆动排序 | 中等</a>
- <a href="#1.195">281. 锯齿迭代器 | 中等</a>
- <a href="#1.196">282. 给表达式添加运算符 | 困难</a>
- <a href="#1.197">283. 移动零 | 简单</a>
- <a href="#1.198">284. 窥视迭代器 | 中等</a>
- <a href="#1.199">285. 二叉搜索树中的中序后继 | 中等</a>
- <a href="#1.200">286. 墙与门 | 中等</a>
- <a href="#1.201">287. 寻找重复数 | 中等</a>
- <a href="#1.202">288. 单词的唯一缩写 | 中等</a>
- <a href="#1.203">289. 生命游戏 | 中等</a>
- <a href="#1.204">291. 单词规律 II | 中等</a>
- <a href="#1.205">292. Nim 游戏 | 简单</a>
- <a href="#1.206">293. 翻转游戏 | 简单</a>
- <a href="#1.207">295. 数据流的中位数 | 困难</a>
- <a href="#1.208">297. 二叉树的序列化与反序列化 | 困难</a>
- <a href="#1.209">299. 猜数字游戏 | 中等</a>
- <a href="#1.210">300. 最长递增子序列 | 中等</a>
- <a href="#1.211">301. 删除无效的括号 | 困难</a>
- <a href="#1.212">308. 二维区域和检索 - 可变 | 困难</a>
- <a href="#1.213">309. 买卖股票的最佳时机含冷冻期 | 中等</a>
- <a href="#1.214">312. 戳气球 | 困难</a>
- <a href="#1.215">315. 计算右侧小于当前元素的个数 | 困难</a>
- <a href="#1.216">322. 零钱兑换 | 中等</a>
- <a href="#1.217">324. 摆动排序 II | 中等</a>
- <a href="#1.218">326. 3 的幂 | 简单</a>
- <a href="#1.219">328. 奇偶链表 | 中等</a>
- <a href="#1.220">329. 矩阵中的最长递增路径 | 困难</a>
- <a href="#1.221">334. 递增的三元子序列 | 中等</a>
- <a href="#1.222">335. 路径交叉 | 困难</a>
- <a href="#1.223">337. 打家劫舍 III | 中等</a>
- <a href="#1.224">338. 比特位计数 | 简单</a>
- <a href="#1.225">340. 至多包含 K 个不同字符的最长子串 | 中等</a>
- <a href="#1.226">341. 扁平化嵌套列表迭代器 | 中等</a>
- <a href="#1.227">344. 反转字符串 | 简单</a>
- <a href="#1.228">347. 前 K 个高频元素 | 中等</a>
- <a href="#1.229">348. 设计井字棋 | 中等</a>
- <a href="#1.230">350. 两个数组的交集 II | 简单</a>
- <a href="#1.231">352. 将数据流变为多个不相交区间 | 困难</a>
- <a href="#1.232">367. 有效的完全平方数 | 简单</a>
- <a href="#1.233">371. 两整数之和 | 中等</a>
- <a href="#1.234">375. 猜数字大小 II | 中等</a>
- <a href="#1.235">378. 有序矩阵中第 K 小的元素 | 中等</a>
- <a href="#1.236">380. O(1) 时间插入、删除和获取随机元素 | 中等</a>
- <a href="#1.237">384. 打乱数组 | 中等</a>
- <a href="#1.238">387. 字符串中的第一个唯一字符 | 简单</a>
- <a href="#1.239">394. 字符串解码 | 中等</a>
- <a href="#1.240">395. 至少有 K 个重复字符的最长子串 | 中等</a>
- <a href="#1.241">399. 除法求值 | 中等</a>
- <a href="#1.242">405. 数字转换为十六进制数 | 简单</a>
- <a href="#1.243">406. 根据身高重建队列 | 中等</a>
- <a href="#1.244">407. 接雨水 II | 困难</a>
- <a href="#1.245">412. Fizz Buzz | 简单</a>
- <a href="#1.246">414. 第三大的数 | 简单</a>
- <a href="#1.247">415. 字符串相加 | 简单</a>
- <a href="#1.248">416. 分割等和子集 | 中等</a>
- <a href="#1.249">434. 字符串中的单词数 | 简单</a>
- <a href="#1.250">437. 路径总和 III | 中等</a>
- <a href="#1.251">438. 找到字符串中所有字母异位词 | 中等</a>
- <a href="#1.252">441. 排列硬币 | 简单</a>
- <a href="#1.253">448. 找到所有数组中消失的数字 | 简单</a>
- <a href="#1.254">453. 最小操作次数使数组元素相等 | 中等</a>
- <a href="#1.255">454. 四数相加 II | 中等</a>
- <a href="#1.256">461. 汉明距离 | 简单</a>
- <a href="#1.257">470. 用 Rand7() 实现 Rand10() | 中等</a>
- <a href="#1.258">476. 数字的补数 | 简单</a>
- <a href="#1.259">482. 密钥格式化 | 简单</a>
- <a href="#1.260">488. 祖玛游戏 | 困难</a>
- <a href="#1.261">489. 扫地机器人 | 困难</a>
- <a href="#1.262">492. 构造矩形 | 简单</a>
- <a href="#1.263">494. 目标和 | 中等</a>
- <a href="#1.264">495. 提莫攻击 | 简单</a>
- <a href="#1.265">496. 下一个更大元素 I | 简单</a>
- <a href="#1.266">500. 键盘行 | 简单</a>
- <a href="#1.267">516. 最长回文子序列 | 中等</a>
- <a href="#1.268">517. 超级洗衣机 | 困难</a>
- <a href="#1.269">520. 检测大写字母 | 简单</a>
- <a href="#1.270">525. 连续数组 | 中等</a>
- <a href="#1.271">538. 把二叉搜索树转换为累加树 | 中等</a>
- <a href="#1.272">543. 二叉树的直径 | 简单</a>
- <a href="#1.273">557. 反转字符串中的单词 III | 简单</a>
- <a href="#1.274">560. 和为 K 的子数组 | 中等</a>
- <a href="#1.275">575. 分糖果 | 简单</a>
- <a href="#1.276">581. 最短无序连续子数组 | 中等</a>
- <a href="#1.277">598. 区间加法 II | 简单</a>
- <a href="#1.278">611. 有效三角形的个数 | 中等</a>
- <a href="#1.279">617. 合并二叉树 | 简单</a>
- <a href="#1.280">621. 任务调度器 | 中等</a>
- <a href="#1.281">629. K 个逆序对数组 | 困难</a>
- <a href="#1.282">638. 大礼包 | 中等</a>
- <a href="#1.283">647. 回文子串 | 中等</a>
- <a href="#1.284">650. 两个键的键盘 | 中等</a>
- <a href="#1.285">673. 最长递增子序列的个数 | 中等</a>
- <a href="#1.286">674. 最长连续递增序列 | 简单</a>
- <a href="#1.287">680. 验证回文串 II | 简单</a>
- <a href="#1.288">698. 划分为 k 个相等的子集 | 中等</a>
- <a href="#1.289">704. 二分查找 | 简单</a>
- <a href="#1.290">718. 最长重复子数组 | 中等</a>
- <a href="#1.291">739. 每日温度 | 中等</a>
- <a href="#1.292">781. 森林中的兔子 | 中等</a>
- <a href="#1.293">869. 重新排序得到 2 的幂 | 中等</a>
- <a href="#1.294">881. 救生艇 | 中等</a>
- <a href="#1.295">902. 最大为 N 的数字组合 | 困难</a>
- <a href="#1.296">911. 在线选举 | 中等</a>
- <a href="#1.297">912. 排序数组 | 中等</a>
- <a href="#1.298">1049. 最后一块石头的重量 II | 中等</a>
- <a href="#1.299">1190. 反转每对括号间的子串 | 中等</a>
- <a href="#1.300">1218. 最长定差子序列 | 中等</a>
- <a href="#1.301">1221. 分割平衡字符串 | 简单</a>
- <a href="#1.302">1262. 可被三整除的最大和 | 中等</a>
- <a href="#1.303">1383. 最大的团队表现值 | 困难</a>
- <a href="#1.304">1401. 圆和矩形是否有重叠 | 中等</a>
- <a href="#1.305">1404. 将二进制表示减到 1 的步骤数 | 中等</a>
- <a href="#1.306">1436. 旅行终点站 | 简单</a>
- <a href="#1.307">1514. 概率最大的路径 | 中等</a>
- <a href="#1.308">1588. 所有奇数长度子数组的和 | 简单</a>
- <a href="#1.309">1605. 给定行和列的和求可行矩阵 | 中等</a>
- <a href="#1.310">1615. 最大网络秩 | 中等</a>
- <a href="#1.311">1616. 分割两个字符串得到回文串 | 中等</a>
- <a href="#1.312">1646. 获取生成数组中的最大值 | 简单</a>
- <a href="#1.313">2208. 将数组和减半的最少操作次数 | 中等</a>
- <a href="#1.314">2369. 检查数组是否存在有效划分 | 中等</a>
- <a href="#1.315">2389. 和有限的最长子序列 | 简单</a>
- <a href="#1.316">3074. 重新分装苹果 | 简单</a>
- <a href="#1.317">3075. 幸福值最大化的选择方案 | 中等</a>
- <a href="#1.318">LCR 069. 山脉数组的峰顶索引 | 简单</a>
- <a href="#1.319">LCR 120. 寻找文件副本 | 简单</a>
- <a href="#1.320">LCR 121. 寻找目标值 - 二维数组 | 中等</a>
- <a href="#1.321">LCR 122. 路径加密 | 简单</a>
- <a href="#1.322">LCR 123. 图书整理 I | 简单</a>
- <a href="#1.323">LCR 124. 推理二叉树 | 中等</a>
- <a href="#1.324">LCR 125. 图书整理 II | 简单</a>
- <a href="#1.325">LCR 126. 斐波那契数 | 简单</a>
- <a href="#1.326">LCR 127. 跳跃训练 | 简单</a>
- <a href="#1.327">LCR 128. 库存管理 I | 简单</a>
- <a href="#1.328">LCR 129. 字母迷宫 | 中等</a>
- <a href="#1.329">LCR 130. 衣橱整理 | 中等</a>
- <a href="#1.330">LCR 131. 砍竹子 I | 中等</a>
- <a href="#1.331">LCR 132. 砍竹子 II | 中等</a>
- <a href="#1.332">LCR 134. Pow(x, n) | 中等</a>
- <a href="#1.333">LCR 140. 训练计划 II | 简单</a>
- <a href="#1.334">LCR 141. 训练计划 III | 简单</a>
- <a href="#1.335">LCR 146. 螺旋遍历二维数组 | 简单</a>
- <a href="#1.336">LCR 155. 将二叉搜索树转化为排序的双向链表 | 中等</a>
- <a href="#1.337">LCR 156. 序列化与反序列化二叉树 | 困难</a>
- <a href="#1.338">LCR 165. 解密数字 | 中等</a>
- <a href="#1.339">LCR 170. 交易逆序对的总数 | 困难</a>
- <a href="#1.340">LCR 174. 寻找二叉搜索树中的目标节点 | 简单</a>
- <a href="#1.341">LCR 180. 文件组合 | 简单</a>
- <a href="#1.342">面试题 17.14. 最小 K 个数 | 中等</a>

</details>

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

## <a id="1"></a>题目

### <a id="1.1"></a>1. 两数之和 | 简单

问题设置: 给定一个乱序正负整数数组, 数组长度量级 1e4, 元素大小量级 1e9, 再给定一个整数 target

要求: 返回数组中两个加起来等于 target 的整数的**下标**. 两个下标不能够相同.

思路:

- 第一反应是排序 + 双指针, 但这样做会丢失下标信息, 需要在找到方案之后再拿着方案回原数组遍历一遍. 时间消耗是 $O(n \log n)$
- 第二反应是使用哈希表, 但是**当时**觉得哈希表的大小和元素大小量级正相关, 为 1e9, 太大了, 于是跳过.
- 第三反应是使用 `std::pair` 存储下标信息, 但转念一想这样做时间复杂度大概率在常数系数意义下大于第一个方案.
- 最后选择第一个方案.
- 由于两个下标不能相同, 在找到第二个下标的过程中不仅要比较数组元素值, 还要比较当前下标是否和第一个下标相同.
- 看了题解之后意识到哈希表的大小是动态增长的, 虽然还是很大但是不会大到 1e9 的量级. 时间消耗是 $O(n)$
- 重新实现之后发现时间消耗确实减少了, 内存消耗也确实增大了.

标签: 哈希表

代码:

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int> &nums, int target) {
        unordered_map<int, int> visited;
        for (int i = 0; i < nums.size(); i++) {
            int current_val = nums[i];
            int val_need_check = target - current_val;
            auto it = visited.find(val_need_check);
            if (it == visited.end()) {
                visited[current_val] = i;
            } else {
                return {it->second, i};
            }
        }
        exit(1);
    }
};
```

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.2"></a>2. 两数相加 | 中等

问题设置: 给定两个链表, 每个链表的元素都是 10 以内的非负整数, 代表一个大整数的每个十进制数码, 整个链表以逆序代表一个大整数.

要求: 以相同的链表表示方式返回这两个链表所代表的整数的和.

思路:

- 第一反应是不使用创建第三条链表的方式, 直接同时不断在两个链表中前进, 遇到 next 两个都非空的情况就照常前进, 遇到两个都是空的情况就视进位 carry 的情况创建新结点并返回, 遇到一空一非空就退出循环, 然后只在非空的链表中继续前进.
- 第二反应也想过不使用创建第三条链表的方式, 直接在短链表末尾追加新结点, 但是由于不认为这一方案会比方案一更优所以先跳过了.
- 题解采用的是方案二, 但是创建了第三条链表作为返回值. 这一方案相比方案一会为短链表额外执行许多判断语句, 但代码思维难度更低.
- 提交结果也证明了方案二确实不如方案一.

代码:

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* result = l1;
        int carry = 0;

        // 进入循环前保证两个指针非空:
        while (1) {
            // 求和并进位:
            int val_1 = l1->val;
            int val_2 = l2->val;
            int sum = val_1 + val_2 + carry;
            carry = sum >= 10 ? 1 : 0;
            sum = sum >= 10 ? sum - 10 : sum;
            l1->val = sum;

            // 如果下两个指针仍然非空:
            if (l1->next && l2->next) {
                l1 = l1->next;
                l2 = l2->next;

                // 继续循环:
                continue;
            }

            // 如果下两个指针为空:
            if (!l1->next && !l2->next) {
                // 说明到头了, 处理剩下的进位:
                if (carry) {
                    l1->next = new ListNode(0);
                    l1->next->val = carry;
                }

                // 直接返回:
                return result;
            }

            // 否则两个链表一长一短, 需要另外处理:
            break;
        }

        // 如果 l1 长则保持原样, 如果是 l2 长则将其嫁接到 l1 后面:
        if (l2->next) {
            l1->next = l2->next;
        }

        // 重复同样的循环:
        l1 = l1->next;
        while (1) {
            int val = l1->val;
            int sum = val + carry;
            carry = sum >= 10 ? 1 : 0;
            sum = sum >= 10 ? sum - 10 : sum;
            l1->val = sum;

            if (l1->next) {
                l1 = l1->next;
                continue;
            }

            if (carry) {
                l1->next = new ListNode(0);
                l1->next->val = carry;
            }

            return result;
        }

        exit(1);
    }
};
```

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.3"></a>3. 无重复字符的最长子串 | 中等

问题设置: 给定一个字符串, 长度的量级为 5 \* 1e4.

要求: 求字符串中满足 "字符不重复" 的最长的子串的**长度**.

思路:

- 第一反应是使用 next 数组. 既然要求一个子串中所有元素不重复, 首先知道一个元素的下一个 (不失一般性, 假设是左边的) 最近相同元素在哪会极大降低问题的实现难度. 思路是使用类似于 KMP 算法中的 next 数组那样的手法. 从当前元素开始向左延伸所能获得的不重复子串必然包含在由当前元素和左边的最近相同元素所包围起来的左开右闭范围中. 在这一范围内当前元素只有一个副本, 可以放心包含当前元素, 因此 "从当前元素开始向左延伸所能获得的不重复子串" 就等于 "在这一范围内从当前元素的左边相邻元素开始向左延伸所能获得的不重复子串" 拼接上 "当前元素". 由于能够通过状态转移求解, 本题可以归入动态规划类型.
- 求解本题的 next 数组的方法是使用一个哈希表存储从特定字符 (char) 到最近一次遇见该字符的下标 (int), 然后从左到右遍历字符串中的每个字符, 如果是首次遇见该字符则 next 值为 -1, 意义是 "可以随意向左延伸而不用担心与当前元素重复的问题"; 否则 next 值为最近一次遇见该字符的下标. 然后更新该字符的最近一次下标为当前下标并继续遍历.
- 一开始使用的哈希表是 `unordered_map`, 为的是减少思维量, 等到通过之后马上改成用整型数组 (因为 `char` 类型的值的变动范围的量级仅为 $2^8$). 优化之后的时间效率直接干爆 97.67% 的提交者.
- 第二反应是使用双指针构成滑动窗口, 但是当时并没有深入思考而是直接跳过了. 具体实现可以是利用一个哈希 (布尔型) 数组记录 (由双指针包围的) 当前的不重复子串的构成信息, 然后通过不断增大右指针从左到右遍历, 对于当前字符, 如果重复, 那么不断缩小左指针并从哈希表中弹出字符直到把当前字符的重复副本也弹出来为止, 此时子串便重新恢复了不重复的性质.

代码:

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.length();

        // 边界情况:
        if (n <= 1) {
            return n;
        }

        vector<int> char2latest_idx(257, -1); // 哈希表, 存储每个字符的最新下标
        vector<int> current2previous_idx(n, -1); // next 数组, 从当前下标跳到左边最近相同字符的下标 (如果没有则跳到 -1)

        // 利用哈希表构造 next 数组:
        for (int i = 0; i < n; i++) {
            // 当前遍历到的字符:
            char &current_char = s[i];

            // 如果是首次遇见该字符:
            if (char2latest_idx[current_char] == -1) {
                // 跳到 -1:
                current2previous_idx[i] = -1;
            } else {
                // 跳到前一个相同字符的下标:
                current2previous_idx[i] = char2latest_idx[current_char];
            }

            // 更新最新下标:
            char2latest_idx[current_char] = i;
        }

        // 利用 next 数组, 采用动态规划思想, 使用滚动数组进行求解:
        int max_no_duplecate_length = 1;
        int current_no_duplecate_length = 1;
        for (int i = 1; i < n; i++) {
            // 动态规划 + 滚动数组:
            current_no_duplecate_length = min(current_no_duplecate_length + 1, i - current2previous_idx[i]);

            // 由于最终答案为所有 n 个元素开始延伸的最长不重复子串的长度的最大值, 所以直接在滚动过程中进行求解最大值:
            max_no_duplecate_length = max(max_no_duplecate_length, current_no_duplecate_length);
        }

        return max_no_duplecate_length;
    }
};
```

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.4"></a>4. 寻找两个正序数组的中位数 | 困难

问题设置: 给定两个升序排序的有序整型数组, 长度均为 1e3 量级.

要求: 返回由这两个数组构成的有序大数组中的中位数. 时间复杂度能优化到 $O(\log (m + n))$ 最好.

思路:

- 第一反应是分割的思路, 将两个数组 (假设一上一下水平并列) 分割为左上, 右上, 左下, 右下四个部分, 其中左上和左下构成逻辑上的合并数组的左半部分, 而右上和右下构成合并数组的右半部分. 一个正确的分割需要满足两个因素:
  - 分割的性质: 左上和左下的所有元素必须小于等于右上和右下的所有元素. 这一条件等价于 "左上和左下的最大元素小于等于右上和右下的最小元素".
  - 分割的大小: 由于求的是**合并数组的中位数**, 左上和左下的元素数量加起来应该等于总数量的一半 (细节等到实现的时候再考虑).
- 自己的实现是使用**解耦**的双指针在两个数组中进行二分查找, 后来证明这个方案不仅思维难度高, 实现起来也是错误百出. 但是由于在实现的过程中还是巩固了一些知识, 认识到了自己的一些不足, 因此还是很有必要将其记录下来. 真要做还是使用**耦合**的双指针, 思维难度直接下降几个量级.
  - 首先是二分法的一些思考:
    - 标记方法:
      - 使用子数组的长度作为子数组范围的标记, 例如使用下标 `left` 和 `right` 标记范围为 `[left, right)` 的子数组.
    - 二分法的过程归纳 (不失一般性, 总是假设当前要进行二分的子数组的左端点下标 `left` 等于 `0`):
      - 排他性二分法:
        - `right >= 3`: 转为 `right == 1` 或 `right == 2` 或 `right >= 3`
        - `right == 2`: 转为 `right == 0` 或 `right == 1`
        - ~~`right == 1`: 边界情况, 需要判定~~
        - ~~`right == 0`: 边界情况, 需要判定~~
        - `right <= 1`: 边界情况, 需要判定
      - 非排他性二分法:
        - `right >= 3`: 转为 `right == 2` 或 `right >= 3`
        - ~~`right == 2`: 往左需要判定, 往右转为 `right == 1`~~
        - ~~`right == 1`: 需要判定~~
        - `right <= 2`: 边界情况, 需要判定
  - 然后是对于本题**解耦的**双指针二分法的思路:
    - 如果不满足分割性质 (排他性二分法):
      - 如果分割大小 "左小右大":
        - 必然要增大左边小边
      - 如果分割大小 "左大右小":
        - 必然要减小左边大边
    - 如果满足分割性质 (非排他性二分法):
      - 如果分割大小 "左小右大":
        - 左边大边和小边同时增大
      - 如果分割大小 "左大右小":
        - 左边大边和小边同时减小
- 看完题解之后发现自己的思路中 "分割" 部分对了, 而 "双指针" 部分则走歪了. 实际上由于要求的分割必然需要满足其大小等于合并数组一半的条件, 两个指针应该是耦合的, 只需要对一个指针进行二分即可. 自己一开始的做法相当于同时需要满足分割大小条件和分割性质条件, 而题解则是在手里捏着已经满足的分割大小条件的情况下仅仅需要满足分割性质条件, 这样做直接把思维难度下降了无数个量级.
- 题解的第二个做法类似于 "使用分治法求有序数组中第 k 大数", 但是本题中由于是双数组, 所以分治的判断条件比较脑筋急转弯. 大致想法是选择一个本来就小于 k 的分割 (例如左上和左下都是 `k / 2 - 1` 的分割), 如果这个分割符合性质, 那就全部收入囊中, 问题转化为求第 `k - 2 * (k / 2 - 1)` 大的数; 如果不符合性质, 那么可以通过裁剪最大值较大的子数组得到一个新的满足性质的分割, 例如左上小于左下, 那么可以裁剪左下直到新分割符合性质, 但是无论如何左上都是不变的, 反过来如果左上大于左下则左下无论如何都是不变的, 结合起来就是最大值较小的子数组可以收入囊中, 问题转化为求第 `k - (k / 2 - 1)` 大的数. 由于自己没有实现这个方案, 所以不知道具体的边界细节, 这里就先不讨论.
- 这道题做了一个下午, 以一种很遗憾的方式达成了**一道困难做一天**的成就.

代码:

```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2) {
        // 边界情况:
        if (nums1.empty() || nums2.empty()) {
            const auto &nums = nums1.empty() ? nums2 : nums1;
            int size = nums.size();
            return size % 2 ? nums[size / 2] : (nums[size / 2 - 1] + nums[size / 2]) / 2.0;
        }

        // 总是使得数组 1 最长, 降低思维难度:
        if (nums1.size() < nums2.size()) {
            swap(nums1, nums2);
        }

        // 优化时间性能:
        int nums1_size = nums1.size();
        int nums2_size = nums2.size();

        int total_size = nums1_size + nums2_size;
        int threshold = total_size / 2;
        bool is_odd = total_size % 2;

        // 对数组 1 进行二分:
        int left = max(0, threshold - nums2_size); // 最左端并不一定是 0, 因为有可能整个数组 2 的元素全部纳入都不够
        int right = min(nums1_size, threshold) + 1; // 最右端同理
        int cut_1, cut_2;
        while (1) {
            // 分别对数组 1 和数组 2 进行切割:
            cut_1 = left + (right - left) / 2;
            cut_2 = threshold - cut_1;

            // 左上和左下的最大值:
            int left_max = get_left_max(nums1, nums2, cut_1, cut_2);

            // 右上和右下的最小值:
            int right_min = get_right_min(nums1, nums2, cut_1, cut_2, nums1_size, nums2_size);

            // 如果分割符合性质直接退出:
            if (left_max <= right_min) {
                break;
            }

            // 否则需要确定往左二分还是往右二分:
            bool is_nums1_bigger = cut_1 == 0 ? false : (cut_2 == 0 ? true : nums1[cut_1 - 1] > nums2[cut_2 - 1]);
            left = is_nums1_bigger ? left : cut_1 + 1; // 条件传送
            right = is_nums1_bigger ? cut_1 : right; // 条件传送
        }

        int left_max = get_left_max(nums1, nums2, cut_1, cut_2);
        int right_min = get_right_min(nums1, nums2, cut_1, cut_2, nums1_size, nums2_size);

        return is_odd ? right_min : (left_max + right_min) / 2.0;
    }

    inline int get_left_max(const vector<int> &nums1, const vector<int> &nums2, const int cut_1, const int cut_2) {
        return cut_1 == 0 ? nums2[cut_2 - 1]
                          : (cut_2 == 0 ? nums1[cut_1 - 1] : max(nums1[cut_1 - 1], nums2[cut_2 - 1]));
    }

    inline int get_right_min(const vector<int> &nums1, const vector<int> &nums2, const int cut_1, const int cut_2,
                             const int nums1_size, const int nums2_size) {
        return cut_1 == nums1_size ? nums2[cut_2]
                                   : (cut_2 == nums2_size ? nums1[cut_1] : min(nums1[cut_1], nums2[cut_2]));
    }
};
```

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.5"></a>5. 最长回文子串 | 中等

问题设置: 给定一个字符串, 长度量级为 1e3.

要求: 返回最长回文子串.

思路:

- 一般的单双中心向两边拓展的动态规划的算法早就做烂了, 这里直接使用 Manacher 算法.
- Manacher 算法采用的也是动态规划的思想, 但是和一般的动态规划算法只往一个方向拓展不同, Manacher 算法利用的性质是回文子串的对称性, 在迭代过程中维护一个右端点最靠右的回文子串, 如果当前遍历到的字符包含在这个右端点最靠右的回文子串中, 那么可以利用当前字符关于右端点最靠右回文子串的中心的对称点的信息对当前字符的回文半径进行初始化, 也就是转移了状态.
- 细节一: 右端点最靠右回文子串只负责其覆盖半径内的信息, 对于覆盖半径外的信息其一概不知 (因为其右端点之外的信息实际上都还没有被遍历过), 所以当前字符初始化的回文半径的初始化值实际上是其 "对称点的回文半径" 和 "对称点距离右端点最靠右回文子串的左端点的距离" 之间的较小值.
- 细节二: 对于遍历到的每一个点, 如果其位于右端点最靠右回文子串的覆盖范围内, 并且对称点的回文范围是右端点最靠右回文子串的覆盖范围的真子集, 那么无需再对其回文半径进行拓展; 反之如果该点位于覆盖半径之外或者其对称点的回文半径触及了右端点最靠右回文子串的左端点, 那么就需要对其进行拓展. 如果能够拓展出去, 那么当前字符就成为新的右端点最靠右回文子串. 由于要么不用拓展, 要么直接拓展完使得拓展范围内的字符不用拓展, 整体的时间复杂度为 $O(n)$.
- 细节三: 由于 Manacher 算法需要对初始字符串进行插入记号 (marker) (一般是字符 `#`) 的预处理, 在求得最长回文子串之后若要转换回原字符串需要在预处理后的字符串和原字符串的下标和回文范围之间进行正确的映射.
  - 对于回文范围, 假设预处理后的字符串的最大回文子串的回文半径 (注意这里是回文半径) 是 `best_P_i`, 通过在草稿纸上简单画图可知该回文子串的右半部分的非 `#` 字符总是可以插入到左半部分的 `#` 字符中, 最后对应到原字符串中的回文范围 (注意这里是回文范围) 总是等于 `best_P_i - 1`.
  - 对于下标, 很容易可推知预处理后的字符串映射回原字符串只需要将下标整除以 2 即可.
    - 原字符串的最长回文子串的左端点可以通过先计算预处理后的字符串的最长回文子串的左端点然后映射回原字符串的方法计算得到.
- 细节四: 右端点最靠右回文子串并不是最长回文子串, 右端点最靠右回文子串的作用只是为了转移状态.
- 细节五: 关于是否需要对原字符串进行预处理, 自己原先是比较疑惑的, 看了[这篇帖子](https://stackoverflow.com/questions/37811437/manachers-algorithm)之后我的想法是在个人实现的时候需要预处理, 正如帖子里那位老哥所说的, 算法本身已经很饶舌了再不预处理一下直接变成天书, 写的人写不懂看的人更看不懂. 如果是生产级别的代码那该优化优化, 不过那就是另一回事了.

代码:

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        // 对原字符串进行备份:
        string s_temp = s;

        // 预处理, 添加 `#` 标记:
        s = add_marker(s);
        int n = s.length();

        // 右端点最靠右回文子串:
        int C = -1;
        int R = 1;
        int C_left_end = C - R + 1; // 左端点

        // 存储每个字符串的回文半径的数组:
        vector<int> P(n, 1);

        // 最长回文子串:
        int best_i = -1;
        int best_P_i = 1;

        // 遍历每个字符:
        for (int i = 0; i < n; i++) {
            char c = s[i];

            int P_i_temp = 1; // 减少内存读写

            // 如果位于右端点最靠右回文子串的覆盖范围内:
            if (i <= C + R - 1) {
                // 求对称点:
                int i2 = 2 * C - i;

                // 对称点的回文半径:
                int P_i2 = P[i2];

                // 如果对称点的回文范围是真子集:
                if (C_left_end < i2 - P_i2 + 1) {
                    // 当前字符无需拓展:
                    P[i] = P_i2;
                    continue;
                }

                // 否则初始化, 准备拓展:
                P_i_temp = i2 - C_left_end + 1;
            }

            // 拓展当前字符的回文半径:
            while (i - P_i_temp >= 0 && i + P_i_temp <= n && s[i - P_i_temp] == s[i + P_i_temp] && ++P_i_temp){}

            P[i] = P_i_temp;

            // 更新右端点最靠右回文子串:
            if (C + R < i + P_i_temp) {
                C = i;
                R = P_i_temp;
                C_left_end = C - R + 1;
            }

            // 更新最长回文子串:
            if (best_P_i < P_i_temp) {
                best_i = i;
                best_P_i = P_i_temp;
            }
        }

        // 将预处理后的字符串映射回原字符串:
        int __n = best_P_i - 1;
        int __pos = (best_i - best_P_i + 1) / 2;

        return s_temp.substr(__pos, __n);
    }

    string add_marker(const string &s) {
        string s2;
        for (const auto &c : s) {
            s2.push_back('#');
            s2.push_back(c);
        }
        s2.push_back('#');
        return s2;
    }
};
```

Manacher 算法做得非常快, 而上面的 "4. 寻找两个正序数组的中位数" 却做了一下午. 这也体现了自己的一个做题的特点就是特别不擅长边界条件多的思路.

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.6"></a>6. Z 字形变换 | 中等

### <a id="1.7"></a>7. 整数反转 | 中等

### <a id="1.8"></a>8. 字符串转换整数 (atoi) | 中等

### <a id="1.9"></a>9. 回文数 | 简单

### <a id="1.10"></a>10. 正则表达式匹配 | 困难

问题设置: 给定一个字符串 `s` 和一个正则表达式模式串 `p`, 两者长度均小于 20. 其中 `p` 仅包含两种模式, `.` (匹配一个任意字符) 和 `*` (匹配任意个特定字符), 并且保证 `*` 前面跟着一个字符. 需要注意的是 `*` 前面跟着的字符有可能是 `.`.

要求: 返回模式串 `p` 是否能够完全匹配 `s`.

思路:

- 第一反应就是使用动态规划.
- 首先要做的是将模式串的两种长度不同的零件 `<char>` 和 `<char>*` 抽象为统一的零件. 这可以通过自定义一个模式类 `Pattern` 来实现.
- 之后使用下标 `i` 索引模式串的零件, 使用下标 `j` 表示字符串 `s` 的范围为 `s[0 : j - 1]` 的子串, 使用数组 `dp[i][j]` 进行状态转移. 现在假设 `i` 固定, 对于每个 `j`, 状态转移方程分为两部分:
  - 如果当前零件是匹配固定字符 (必须匹配 1 个字符), 那么对于 `.` 来说任意非空子串都能转移状态至子串 `s[0 : j - 2]`, 除了空子串, 空子串必定失配 (因为必须要匹配一个字符, 而空子串没有字符); 而对于其他任意字符而言当且仅当最后一个字符 `s[j - 1]` 与当前字符相同时非空字串能够转移状态, 而空子串仍然必定失配.
  - 如果当前零件是带星号字符 (可能匹配 0 或多个字符), 那么不论子串是空子串还是非空子串都需要尝试匹配, 因为一次可以吞掉 0 个或多个相同字符 (`s[j - 1]`, `s[j - 2]`, ...), 并且每吞掉一个字符都需要进行一次状态转移, 只要这些转移状态后的其中一种子情况能够匹配那么当前子串 `s[0 : j - 1]` 就能够匹配. 也就是说对于带星号零件而言匹配过程是个双循环.

代码:

```cpp
// 自定义的模式类:
class Pattern {
private:
    int _length;
    vector<string> parts;

public:
    size_t length() {
        return _length;
    }
    string get_part_by_index(int index) {
        if (index < 0 || index >= _length) {
            throw out_of_range("");
        }
        return parts[index];
    }
    Pattern(const string &pattern) {
        _length = 0;
        int i = 0;
        int pattern_length = pattern.length();

        // 提取所有零件:
        while (i < pattern_length) {
            char c = pattern[i];
            i++;
            string part({c});
            if (i < pattern_length && pattern[i] == '*') {
                part.push_back('*');
                i++;
            }
            parts.emplace_back(part);
            _length++;
        }
    }
};

class Solution {
public:
    bool isMatch(string s, string p) {
        auto my_pattern = Pattern(p);
        int s_length = s.length();
        int p_length = my_pattern.length();
        vector<bool> dp(s_length + 1, false);
        dp[0] = true;

        // 遍历每个零件:
        for (int i = 0; i < p_length; i++) {
            // 获取零件:
            string part = my_pattern.get_part_by_index(i);
            int part_length = part.length();

            // 固定字符 (必须匹配 1 个字符):
            if (part_length == 1) {
                char c = part[0];

                // 匹配任意字符 (单次):
                if (c == '.') {
                    // 任意非空子串都能转移状态:
                    for (int j = s_length; j >= 1; j--) {
                        dp[j] = dp[j - 1];
                    }

                    // 空子串失配:
                    dp[0] = false;
                }

                // 匹配特定字符 (单次):
                else {
                    // 仅 "最后一个字符与当前字符相同" 的非空字串能够转移状态:
                    for (int j = s_length; j >= 1; j--) {
                        dp[j] = c == s[j - 1] ? dp[j - 1] : false;
                    }

                    // 空子串必定失配:
                    dp[0] = false;
                }
            }

            // 带星号字符 (可能匹配 0 或多个字符):
            else {
                char c = part[0];

                // 注意此处同样能够匹配空字串:
                for (int j = s_length; j >= 0; j--) {
                    // 匹配 0 个字符:
                    if (dp[j]) {
                        continue;
                    }

                    // 尝试匹配多个字符:
                    bool dp_j = false;
                    for (int k = j - 1; k >= 0 && (c == '.' || c == s[k]) && !(dp_j = dp[k]); k--) {
                    }
                    dp[j] = dp_j;
                }
            }
        }
        return dp[s_length];
    }
};
```

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.11"></a>11. 盛最多水的容器 | 中等

问题设置: 给定 `n` 个非负整数, 分别代表坐标轴上 `x = 0`, `x = 1`, ..., `x = n - 1` 处的 "墙壁" 高度. `n` 的量级为 1e5.

要求: 返回使用其中任意两个墙壁和底部 x 轴构成的桶所能装的水的最大体积.

思路:

- 这道题应该列入困难题. 我认为的困难题要么确实是很难, 要么是那种脑子转不过来的时候怎么都做不出来的题. 本题明显属于后者.
- 第一反应是单调栈, 但是有反例: `[1, 2, 2, 1]`. 单调栈无法解决这种中间凸的情况.
- 第二反应是由外至内的双指针, 虽然这一方案确实是正确方案, 但是当时自己认为对于墙壁高度分布对称的情况这一方案无法计算下一步而放弃了这一方案.
- 第三反应是由左至右的双指针, 其中右指针负责外循环, 左指针负责内循环. 固定右指针, 左指针沿着向左的递减序列不断向左边递减; 而右指针则沿着右边的递减序列不断向右边递减. 这一方案虽然能够通过时间限制, 但时间复杂度依然很高.
- 最后看了题解发现第二个方案是正确的. 当选择了左右两端的墙壁 A 和 B 之后, 较矮的墙壁 (假设为 A) 的潜力就已经发挥完全了, 这是因为桶的高度等于两个墙壁的高度的较小值, 若将右指针向内移动, 如果 B 变高, 桶的高度不会增加 (因为取决于较小值, 而较小值 A 此时不变), 如果 B 变矮, 桶的高度不仅不会增加反而还有可能减小, 而宽度无论如何都是减小的, 所以对于 A 来说, 和 B 计算完一次桶的体积之后 A 就完全可以 "弃用" 了. 至于本题的双指针做法仅仅是基于所有这些推导之上的手段罢了. 本题非常取巧, 建议背诵, 不建议理解.
- 为什么由内向外不行而由外向内却可以, 自己思考了一下认为原因是题目要求的是最大值, 而由内向外的做法会造成桶的宽度的增加因此每次都需要重新检查, 而由外向内的做法桶的宽度是减小的, 因此能做到一步到位.
- 从本题学习到的思想和 "4. 寻找两个正序数组的中位数" 类似, 都是要尽量捏住问题的一个维度 (题目 "4. 寻找两个正序数组的中位数" 中是分割的大小保持不变, 本题中是桶的宽度由大到小遍历).

代码:

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int l = 0;
        int r = height.size() - 1;
        int result = 0;
        while(l < r){
            int height_l = height[l];
            int height_r = height[r];
            result = max(result, min(height_l, height_r) * (r - l));
            int left_adjust = height_l < height_r ? 1 : 0;
            l += left_adjust;
            r -= (1 - left_adjust);
        }
        return result;
    }
};
```

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.12"></a>12. 整数转罗马数字 | 中等

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.13"></a>13. 罗马数字转整数 | 简单

### <a id="1.14"></a>14. 最长公共前缀 | 简单

### <a id="1.15"></a>15. 三数之和 | 中等

### <a id="1.16"></a>16. 最接近的三数之和 | 中等

### <a id="1.17"></a>17. 电话号码的字母组合 | 中等

### <a id="1.18"></a>18. 四数之和 | 中等

### <a id="1.19"></a>19. 删除链表的倒数第 N 个结点 | 中等

### <a id="1.20"></a>20. 有效的括号 | 简单

### <a id="1.21"></a>21. 合并两个有序链表 | 简单

### <a id="1.22"></a>22. 括号生成 | 中等

### <a id="1.23"></a>23. 合并 K 个升序链表 | 困难

### <a id="1.24"></a>25. K 个一组翻转链表 | 困难

### <a id="1.25"></a>26. 删除有序数组中的重复项 | 简单

### <a id="1.26"></a>28. 找出字符串中第一个匹配项的下标 | 简单

### <a id="1.27"></a>29. 两数相除 | 中等

### <a id="1.28"></a>31. 下一个排列 | 中等

### <a id="1.29"></a>32. 最长有效括号 | 困难

### <a id="1.30"></a>33. 搜索旋转排序数组 | 中等

### <a id="1.31"></a>34. 在排序数组中查找元素的第一个和最后一个位置 | 中等

### <a id="1.32"></a>35. 搜索插入位置 | 简单

### <a id="1.33"></a>36. 有效的数独 | 中等

### <a id="1.34"></a>38. 外观数列 | 中等

### <a id="1.35"></a>39. 组合总和 | 中等

### <a id="1.36"></a>40. 组合总和 II | 中等

### <a id="1.37"></a>41. 缺失的第一个正数 | 困难

### <a id="1.38"></a>42. 接雨水 | 困难

### <a id="1.39"></a>43. 字符串相乘 | 中等

### <a id="1.40"></a>44. 通配符匹配 | 困难

### <a id="1.41"></a>45. 跳跃游戏 II | 中等

### <a id="1.42"></a>46. 全排列 | 中等

### <a id="1.43"></a>48. 旋转图像 | 中等

### <a id="1.44"></a>49. 字母异位词分组 | 中等

### <a id="1.45"></a>50. Pow(x, n) | 中等

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.46"></a>51. N 皇后 | 困难

### <a id="1.47"></a>53. 最大子数组和 | 中等

### <a id="1.48"></a>54. 螺旋矩阵 | 中等

### <a id="1.49"></a>55. 跳跃游戏 | 中等

### <a id="1.50"></a>56. 合并区间 | 中等

### <a id="1.51"></a>58. 最后一个单词的长度 | 简单

### <a id="1.52"></a>59. 螺旋矩阵 II | 中等

### <a id="1.53"></a>61. 旋转链表 | 中等

### <a id="1.54"></a>62. 不同路径 | 中等

### <a id="1.55"></a>63. 不同路径 II | 中等

### <a id="1.56"></a>64. 最小路径和 | 中等

### <a id="1.57"></a>66. 加一 | 简单

### <a id="1.58"></a>69. x 的平方根 | 简单

### <a id="1.59"></a>70. 爬楼梯 | 简单

### <a id="1.60"></a>72. 编辑距离 | 中等

### <a id="1.61"></a>73. 矩阵置零 | 中等

### <a id="1.62"></a>75. 颜色分类 | 中等

### <a id="1.63"></a>76. 最小覆盖子串 | 困难

### <a id="1.64"></a>78. 子集 | 中等

### <a id="1.65"></a>79. 单词搜索 | 中等

### <a id="1.66"></a>84. 柱状图中最大的矩形 | 困难

### <a id="1.67"></a>85. 最大矩形 | 困难

### <a id="1.68"></a>88. 合并两个有序数组 | 简单

### <a id="1.69"></a>89. 格雷编码 | 中等

### <a id="1.70"></a>91. 解码方法 | 中等

### <a id="1.71"></a>92. 反转链表 II | 中等

### <a id="1.72"></a>93. 复原 IP 地址 | 中等

### <a id="1.73"></a>94. 二叉树的中序遍历 | 简单

### <a id="1.74"></a>96. 不同的二叉搜索树 | 中等

### <a id="1.75"></a>98. 验证二叉搜索树 | 中等

### <a id="1.76"></a>101. 对称二叉树 | 简单

### <a id="1.77"></a>102. 二叉树的层序遍历 | 中等

### <a id="1.78"></a>103. 二叉树的锯齿形层序遍历 | 中等

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.79"></a>104. 二叉树的最大深度 | 简单

### <a id="1.80"></a>105. 从前序与中序遍历序列构造二叉树 | 中等

### <a id="1.81"></a>108. 将有序数组转换为二叉搜索树 | 简单

### <a id="1.82"></a>114. 二叉树展开为链表 | 中等

### <a id="1.83"></a>115. 不同的子序列 | 困难

### <a id="1.84"></a>116. 填充每个节点的下一个右侧节点指针 | 中等

### <a id="1.85"></a>118. 杨辉三角 | 简单

### <a id="1.86"></a>119. 杨辉三角 II | 简单

### <a id="1.87"></a>120. 三角形最小路径和 | 中等

### <a id="1.88"></a>121. 买卖股票的最佳时机 | 简单

### <a id="1.89"></a>122. 买卖股票的最佳时机 II | 中等

### <a id="1.90"></a>124. 二叉树中的最大路径和 | 困难

### <a id="1.91"></a>125. 验证回文串 | 简单

### <a id="1.92"></a>127. 单词接龙 | 困难

### <a id="1.93"></a>128. 最长连续序列 | 中等

### <a id="1.94"></a>130. 被围绕的区域 | 中等

### <a id="1.95"></a>131. 分割回文串 | 中等

### <a id="1.96"></a>134. 加油站 | 中等

### <a id="1.97"></a>135. 分发糖果 | 困难

### <a id="1.98"></a>136. 只出现一次的数字 | 简单

### <a id="1.99"></a>138. 随机链表的复制 | 中等

### <a id="1.100"></a>139. 单词拆分 | 中等

### <a id="1.101"></a>140. 单词拆分 II | 困难

### <a id="1.102"></a>141. 环形链表 | 简单

### <a id="1.103"></a>142. 环形链表 II | 中等

### <a id="1.104"></a>143. 重排链表 | 中等

### <a id="1.105"></a>146. LRU 缓存 | 中等

### <a id="1.106"></a>148. 排序链表 | 中等

### <a id="1.107"></a>149. 直线上最多的点数 | 困难

### <a id="1.108"></a>150. 逆波兰表达式求值 | 中等

### <a id="1.109"></a>152. 乘积最大子数组 | 中等

### <a id="1.110"></a>153. 寻找旋转排序数组中的最小值 | 中等

### <a id="1.111"></a>154. 寻找旋转排序数组中的最小值 II | 困难

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.112"></a>155. 最小栈 | 中等

### <a id="1.113"></a>156. 上下翻转二叉树 | 中等

### <a id="1.114"></a>157. 用 Read4 读取 N 个字符 | 简单

### <a id="1.115"></a>158. 用 Read4 读取 N 个字符 II - 多次调用 | 困难

### <a id="1.116"></a>159. 至多包含两个不同字符的最长子串 | 中等

### <a id="1.117"></a>160. 相交链表 | 简单

### <a id="1.118"></a>161. 相隔为 1 的编辑距离 | 中等

### <a id="1.119"></a>162. 寻找峰值 | 中等

### <a id="1.120"></a>163. 缺失的区间 | 简单

### <a id="1.121"></a>165. 比较版本号 | 中等

### <a id="1.122"></a>166. 分数到小数 | 中等

### <a id="1.123"></a>169. 多数元素 | 简单

### <a id="1.124"></a>170. 两数之和 III - 数据结构设计 | 简单

### <a id="1.125"></a>171. Excel 表列序号 | 简单

### <a id="1.126"></a>172. 阶乘后的零 | 中等

### <a id="1.127"></a>179. 最大数 | 中等

### <a id="1.128"></a>186. 反转字符串中的单词 II | 中等

### <a id="1.129"></a>187. 重复的 DNA 序列 | 中等

### <a id="1.130"></a>189. 轮转数组 | 中等

### <a id="1.131"></a>190. 颠倒二进制位 | 简单

### <a id="1.132"></a>191. 位 1 的个数 | 简单

### <a id="1.133"></a>198. 打家劫舍 | 中等

### <a id="1.134"></a>199. 二叉树的右视图 | 中等

### <a id="1.135"></a>200. 岛屿数量 | 中等

### <a id="1.136"></a>202. 快乐数 | 简单

### <a id="1.137"></a>204. 计数质数 | 中等

### <a id="1.138"></a>206. 反转链表 | 简单

### <a id="1.139"></a>207. 课程表 | 中等

### <a id="1.140"></a>208. 实现 Trie (前缀树) | 中等

### <a id="1.141"></a>210. 课程表 II | 中等

### <a id="1.142"></a>211. 添加与搜索单词 - 数据结构设计 | 中等

### <a id="1.143"></a>212. 单词搜索 II | 困难

### <a id="1.144"></a>213. 打家劫舍 II | 中等

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.145"></a>215. 数组中的第 K 个最大元素 | 中等

### <a id="1.146"></a>217. 存在重复元素 | 简单

### <a id="1.147"></a>218. 天际线问题 | 困难

### <a id="1.148"></a>221. 最大正方形 | 中等

### <a id="1.149"></a>223. 矩形面积 | 中等

### <a id="1.150"></a>226. 翻转二叉树 | 简单

### <a id="1.151"></a>227. 基本计算器 II | 中等

### <a id="1.152"></a>229. 多数元素 II | 中等

### <a id="1.153"></a>230. 二叉搜索树中第 K 小的元素 | 中等

### <a id="1.154"></a>231. 2 的幂 | 简单

### <a id="1.155"></a>234. 回文链表 | 简单

### <a id="1.156"></a>235. 二叉搜索树的最近公共祖先 | 中等

### <a id="1.157"></a>236. 二叉树的最近公共祖先 | 中等

### <a id="1.158"></a>237. 删除链表中的节点 | 中等

### <a id="1.159"></a>238. 除自身以外数组的乘积 | 中等

### <a id="1.160"></a>239. 滑动窗口最大值 | 困难

### <a id="1.161"></a>240. 搜索二维矩阵 II | 中等

### <a id="1.162"></a>242. 有效的字母异位词 | 简单

### <a id="1.163"></a>243. 最短单词距离 | 简单

### <a id="1.164"></a>244. 最短单词距离 II | 中等

### <a id="1.165"></a>245. 最短单词距离 III | 中等

### <a id="1.166"></a>246. 中心对称数 | 简单

### <a id="1.167"></a>247. 中心对称数 II | 中等

### <a id="1.168"></a>248. 中心对称数 III | 困难

### <a id="1.169"></a>249. 移位字符串分组 | 中等

### <a id="1.170"></a>250. 统计同值子树 | 中等

### <a id="1.171"></a>251. 展开二维向量 | 中等

### <a id="1.172"></a>252. 会议室 | 简单

### <a id="1.173"></a>253. 会议室 II | 中等

### <a id="1.174"></a>254. 因子的组合 | 中等

### <a id="1.175"></a>255. 验证二叉搜索树的前序遍历序列 | 中等

### <a id="1.176"></a>256. 粉刷房子 | 中等

### <a id="1.177"></a>258. 各位相加 | 简单

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.178"></a>259. 较小的三数之和 | 中等

### <a id="1.179"></a>260. 只出现一次的数字 III | 中等

### <a id="1.180"></a>261. 以图判树 | 中等

### <a id="1.181"></a>265. 粉刷房子 II | 困难

### <a id="1.182"></a>266. 回文排列 | 简单

### <a id="1.183"></a>267. 回文排列 II | 中等

### <a id="1.184"></a>268. 丢失的数字 | 简单

### <a id="1.185"></a>269. 火星词典 | 困难

### <a id="1.186"></a>270. 最接近的二叉搜索树值 | 简单

### <a id="1.187"></a>271. 字符串的编码与解码 | 中等

### <a id="1.188"></a>272. 最接近的二叉搜索树值 II | 困难

### <a id="1.189"></a>273. 整数转换英文表示 | 困难

### <a id="1.190"></a>276. 栅栏涂色 | 中等

### <a id="1.191"></a>277. 搜寻名人 | 中等

### <a id="1.192"></a>278. 第一个错误的版本 | 简单

### <a id="1.193"></a>279. 完全平方数 | 中等

### <a id="1.194"></a>280. 摆动排序 | 中等

### <a id="1.195"></a>281. 锯齿迭代器 | 中等

### <a id="1.196"></a>282. 给表达式添加运算符 | 困难

### <a id="1.197"></a>283. 移动零 | 简单

### <a id="1.198"></a>284. 窥视迭代器 | 中等

### <a id="1.199"></a>285. 二叉搜索树中的中序后继 | 中等

### <a id="1.200"></a>286. 墙与门 | 中等

### <a id="1.201"></a>287. 寻找重复数 | 中等

### <a id="1.202"></a>288. 单词的唯一缩写 | 中等

### <a id="1.203"></a>289. 生命游戏 | 中等

### <a id="1.204"></a>291. 单词规律 II | 中等

### <a id="1.205"></a>292. Nim 游戏 | 简单

### <a id="1.206"></a>293. 翻转游戏 | 简单

### <a id="1.207"></a>295. 数据流的中位数 | 困难

### <a id="1.208"></a>297. 二叉树的序列化与反序列化 | 困难

### <a id="1.209"></a>299. 猜数字游戏 | 中等

### <a id="1.210"></a>300. 最长递增子序列 | 中等

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.211"></a>301. 删除无效的括号 | 困难

### <a id="1.212"></a>308. 二维区域和检索 - 可变 | 困难

### <a id="1.213"></a>309. 买卖股票的最佳时机含冷冻期 | 中等

### <a id="1.214"></a>312. 戳气球 | 困难

### <a id="1.215"></a>315. 计算右侧小于当前元素的个数 | 困难

### <a id="1.216"></a>322. 零钱兑换 | 中等

### <a id="1.217"></a>324. 摆动排序 II | 中等

### <a id="1.218"></a>326. 3 的幂 | 简单

### <a id="1.219"></a>328. 奇偶链表 | 中等

### <a id="1.220"></a>329. 矩阵中的最长递增路径 | 困难

### <a id="1.221"></a>334. 递增的三元子序列 | 中等

### <a id="1.222"></a>335. 路径交叉 | 困难

### <a id="1.223"></a>337. 打家劫舍 III | 中等

### <a id="1.224"></a>338. 比特位计数 | 简单

### <a id="1.225"></a>340. 至多包含 K 个不同字符的最长子串 | 中等

### <a id="1.226"></a>341. 扁平化嵌套列表迭代器 | 中等

### <a id="1.227"></a>344. 反转字符串 | 简单

### <a id="1.228"></a>347. 前 K 个高频元素 | 中等

### <a id="1.229"></a>348. 设计井字棋 | 中等

### <a id="1.230"></a>350. 两个数组的交集 II | 简单

### <a id="1.231"></a>352. 将数据流变为多个不相交区间 | 困难

### <a id="1.232"></a>367. 有效的完全平方数 | 简单

### <a id="1.233"></a>371. 两整数之和 | 中等

### <a id="1.234"></a>375. 猜数字大小 II | 中等

### <a id="1.235"></a>378. 有序矩阵中第 K 小的元素 | 中等

### <a id="1.236"></a>380. O(1) 时间插入、删除和获取随机元素 | 中等

### <a id="1.237"></a>384. 打乱数组 | 中等

### <a id="1.238"></a>387. 字符串中的第一个唯一字符 | 简单

### <a id="1.239"></a>394. 字符串解码 | 中等

### <a id="1.240"></a>395. 至少有 K 个重复字符的最长子串 | 中等

### <a id="1.241"></a>399. 除法求值 | 中等

### <a id="1.242"></a>405. 数字转换为十六进制数 | 简单

### <a id="1.243"></a>406. 根据身高重建队列 | 中等

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.244"></a>407. 接雨水 II | 困难

### <a id="1.245"></a>412. Fizz Buzz | 简单

### <a id="1.246"></a>414. 第三大的数 | 简单

### <a id="1.247"></a>415. 字符串相加 | 简单

### <a id="1.248"></a>416. 分割等和子集 | 中等

### <a id="1.249"></a>434. 字符串中的单词数 | 简单

### <a id="1.250"></a>437. 路径总和 III | 中等

### <a id="1.251"></a>438. 找到字符串中所有字母异位词 | 中等

### <a id="1.252"></a>441. 排列硬币 | 简单

### <a id="1.253"></a>448. 找到所有数组中消失的数字 | 简单

### <a id="1.254"></a>453. 最小操作次数使数组元素相等 | 中等

### <a id="1.255"></a>454. 四数相加 II | 中等

### <a id="1.256"></a>461. 汉明距离 | 简单

### <a id="1.257"></a>470. 用 Rand7() 实现 Rand10() | 中等

### <a id="1.258"></a>476. 数字的补数 | 简单

### <a id="1.259"></a>482. 密钥格式化 | 简单

### <a id="1.260"></a>488. 祖玛游戏 | 困难

### <a id="1.261"></a>489. 扫地机器人 | 困难

### <a id="1.262"></a>492. 构造矩形 | 简单

### <a id="1.263"></a>494. 目标和 | 中等

### <a id="1.264"></a>495. 提莫攻击 | 简单

### <a id="1.265"></a>496. 下一个更大元素 I | 简单

### <a id="1.266"></a>500. 键盘行 | 简单

### <a id="1.267"></a>516. 最长回文子序列 | 中等

### <a id="1.268"></a>517. 超级洗衣机 | 困难

### <a id="1.269"></a>520. 检测大写字母 | 简单

### <a id="1.270"></a>525. 连续数组 | 中等

### <a id="1.271"></a>538. 把二叉搜索树转换为累加树 | 中等

### <a id="1.272"></a>543. 二叉树的直径 | 简单

### <a id="1.273"></a>557. 反转字符串中的单词 III | 简单

### <a id="1.274"></a>560. 和为 K 的子数组 | 中等

### <a id="1.275"></a>575. 分糖果 | 简单

### <a id="1.276"></a>581. 最短无序连续子数组 | 中等

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.277"></a>598. 区间加法 II | 简单

### <a id="1.278"></a>611. 有效三角形的个数 | 中等

### <a id="1.279"></a>617. 合并二叉树 | 简单

### <a id="1.280"></a>621. 任务调度器 | 中等

### <a id="1.281"></a>629. K 个逆序对数组 | 困难

### <a id="1.282"></a>638. 大礼包 | 中等

### <a id="1.283"></a>647. 回文子串 | 中等

### <a id="1.284"></a>650. 两个键的键盘 | 中等

### <a id="1.285"></a>673. 最长递增子序列的个数 | 中等

### <a id="1.286"></a>674. 最长连续递增序列 | 简单

### <a id="1.287"></a>680. 验证回文串 II | 简单

### <a id="1.288"></a>698. 划分为 k 个相等的子集 | 中等

### <a id="1.289"></a>704. 二分查找 | 简单

### <a id="1.290"></a>718. 最长重复子数组 | 中等

### <a id="1.291"></a>739. 每日温度 | 中等

### <a id="1.292"></a>781. 森林中的兔子 | 中等

### <a id="1.293"></a>869. 重新排序得到 2 的幂 | 中等

### <a id="1.294"></a>881. 救生艇 | 中等

### <a id="1.295"></a>902. 最大为 N 的数字组合 | 困难

### <a id="1.296"></a>911. 在线选举 | 中等

### <a id="1.297"></a>912. 排序数组 | 中等

### <a id="1.298"></a>1049. 最后一块石头的重量 II | 中等

### <a id="1.299"></a>1190. 反转每对括号间的子串 | 中等

### <a id="1.300"></a>1218. 最长定差子序列 | 中等

### <a id="1.301"></a>1221. 分割平衡字符串 | 简单

### <a id="1.302"></a>1262. 可被三整除的最大和 | 中等

### <a id="1.303"></a>1383. 最大的团队表现值 | 困难

### <a id="1.304"></a>1401. 圆和矩形是否有重叠 | 中等

### <a id="1.305"></a>1404. 将二进制表示减到 1 的步骤数 | 中等

### <a id="1.306"></a>1436. 旅行终点站 | 简单

### <a id="1.307"></a>1514. 概率最大的路径 | 中等

### <a id="1.308"></a>1588. 所有奇数长度子数组的和 | 简单

### <a id="1.309"></a>1605. 给定行和列的和求可行矩阵 | 中等

<div align="right"><b><a href="#toc">返回顶部↑</a></b></div>

### <a id="1.310"></a>1615. 最大网络秩 | 中等

### <a id="1.311"></a>1616. 分割两个字符串得到回文串 | 中等

### <a id="1.312"></a>1646. 获取生成数组中的最大值 | 简单

### <a id="1.313"></a>2208. 将数组和减半的最少操作次数 | 中等

### <a id="1.314"></a>2369. 检查数组是否存在有效划分 | 中等

### <a id="1.315"></a>2389. 和有限的最长子序列 | 简单

### <a id="1.316"></a>3074. 重新分装苹果 | 简单

### <a id="1.317"></a>3075. 幸福值最大化的选择方案 | 中等

### <a id="1.318"></a>LCR 069. 山脉数组的峰顶索引 | 简单

### <a id="1.319"></a>LCR 120. 寻找文件副本 | 简单

### <a id="1.320"></a>LCR 121. 寻找目标值 - 二维数组 | 中等

### <a id="1.321"></a>LCR 122. 路径加密 | 简单

### <a id="1.322"></a>LCR 123. 图书整理 I | 简单

### <a id="1.323"></a>LCR 124. 推理二叉树 | 中等

### <a id="1.324"></a>LCR 125. 图书整理 II | 简单

### <a id="1.325"></a>LCR 126. 斐波那契数 | 简单

### <a id="1.326"></a>LCR 127. 跳跃训练 | 简单

### <a id="1.327"></a>LCR 128. 库存管理 I | 简单

### <a id="1.328"></a>LCR 129. 字母迷宫 | 中等

### <a id="1.329"></a>LCR 130. 衣橱整理 | 中等

### <a id="1.330"></a>LCR 131. 砍竹子 I | 中等

### <a id="1.331"></a>LCR 132. 砍竹子 II | 中等

### <a id="1.332"></a>LCR 134. Pow(x, n) | 中等

### <a id="1.333"></a>LCR 140. 训练计划 II | 简单

### <a id="1.334"></a>LCR 141. 训练计划 III | 简单

### <a id="1.335"></a>LCR 146. 螺旋遍历二维数组 | 简单

### <a id="1.336"></a>LCR 155. 将二叉搜索树转化为排序的双向链表 | 中等

### <a id="1.337"></a>LCR 156. 序列化与反序列化二叉树 | 困难

### <a id="1.338"></a>LCR 165. 解密数字 | 中等

### <a id="1.339"></a>LCR 170. 交易逆序对的总数 | 困难

### <a id="1.340"></a>LCR 174. 寻找二叉搜索树中的目标节点 | 简单

### <a id="1.341"></a>LCR 180. 文件组合 | 简单

### <a id="1.342"></a>面试题 17.14. 最小 K 个数 | 中等
